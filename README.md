# üéÆ Controller Mapper JUCE Application

A JUCE-based MIDI controller mapping tool for PlayStation controllers.

Watch my [Demo Video üìΩÔ∏è](https://youtu.be/OB9Wi6VK8hE?si=mHcPfyyRAZtk5BY6)

## üìã Overview

This application detects gamepads connected to your PC and allows you to map PlayStation controller inputs to MIDI messages for use in your DAW. While support is currently to be limited to DualShock PS4 controllers, future versions may introduce dynamic detection and mapping for other devices.

## ‚ú® Projected Features

- üéÆ **Controller Detection**  
  Detects connected gamepads and verifies if the controller is supported (currently only DualShock PS4).

- üß† **Input Mapping to MIDI**  
  View real-time MIDI messages generated by controller input in a dedicated MIDI console.

- üéõÔ∏è **Custom GUI for Mapping**  
  Assign controller inputs to modulation parameters in your DAW through an intuitive graphical interface.

- üìÅ **Scene Management**  
  Create, save, and load different mapping "scenes" for different projects or workflows. Seamlessly switch between scenes live.

- üéöÔ∏è **DAW Transport Integration**  
  Includes MIDI controls for common DAW transport actions:
  - Play
  - Stop
  - Record
  - Zoom
  - Scroll
  - Engage Loop

## üîß Technologies Used

- [JUCE](https://juce.com/) ‚Äî Cross-platform C++ framework for audio and GUI applications  
- [SDL3](https://github.com/libsdl-org/SDL) ‚Äî Used for gamepad input handling  
- C++17 ‚Äî Main programming language

## üöÄ Getting Started

> ‚ö†Ô∏è **Note:** This app currently only supports PlayStation DualShock 4 controllers. Other controllers will not be recognized.

### Prerequisites

- JUCE 7+
- C++17-compatible compiler
- SDL3 development libraries
- A DualShock PS4 controller

### Notes

In order for SDL3 to work, you need to add a copy of the executable to your build folder.
copy SDL3.dll from lib/SDL3/bin/SDL3.dll
and add to /Builds/VisualStudio2022/x64/Debug/

So I've thought harder about my usee case and whether or not JUCE is a good fit for my project. It seems like JUCE is a lot of unnecessary bulk.
I'm not processing audio or receiving MIDI, and I have to use 3rd party tools to receive controller input (SDL) and send midi output (midiLoop/rtmidi)
The main perk of JUCE at this point is gonna be the GUI Building. I'm gonna use the juce::Timer to poll messages, and I'll use their midi message object for creating midi messages. But man... I'vee put a lot of time into this, particularly learning JUCE stuff, and now it feels like I could accomplish my product without JUCE haha.

Something useful from SDL's documentation: use SDL_AddEventWatch() to set a callback when a new event arrives. 
This might be a good way to alert users of controller connect/disconnect.

When a controller connected at a time besides startup, it needs to be opened (or opened again even if it was previously connected during runtime).

my controller seems to send axis motion signals while idling. I can look into disregarding signals below a certain threshold? it's an old controller. 
Can add a "dead-zone" to fix this.

I'm worried that my SDL event polling is too slow and I can't keep up, but it's difficult to tell until I can remove the pollution caused by idle axis motion

I had a great idea for some functionality down the line for this application. My original concept was for a performance tool. edit parameters of audio in real time with a gamepad. Create a unique customizable control scheme that could be useful for live adjusting parameters in music. But as I was working on the logic for selecting an active controller, I thought to myself that it would actually be cool to allow any number of active controllers, the same way Ableton lets users have many active midi controllers that are enabled for certain things and not for others. Anyways, that got me thinking I could make my original idea as a "performance mode" and then also I could have a mode that works like a party game. People could still have customizable controls and stuff, but there could be hero's in the game, like a time warp character, a reverb/delay character, a termolo/vibrato character, etc. And It could be like a minigame party mode. 

Possible bug, controller does not snap back to zero with joysticks because of time between messages and deadzone. I need to make sure that just because I'm not logging my deadzone doesn't mean I'm not using the value there.

Transport controls send commands using MCU / HUI protocols.

Here's a table chatgpt game me for MCU/HUI specific midi messages for DAW transports. For starters I'm gonna get my joysticks hooked up to my daw I think.
Command	   MIDI Message (Hex)
Play	     90 5E 7F
Stop	     90 5D 7F
Record	   90 5F 7F
Rewind	   90 5B 7F
Fast Fwd	 90 5C 7F

Midi CC messages can have a cc_number between 0 and 127, but some of these are reserved for special functions. For app users, it isn't necessary for them to know the CC message each axis is assigned to, the DAW can automatically detect and learn a CC association.

CC numbers to avoid custom assigning:
CC 0 (Bank Select MSB)
CC 1 (Mod Wheel)
CC 7 (Volume)
CC 10 (Pan)
CC 64 (Sustain Pedal)
CC 120‚Äì127 (All notes off, omni mode, etc.)

Let's say that we only give users 6 cc numbers per scene. one for each axis. And we don't give them buttons/triggers?
Each controller can have its own midi channel? (This might be confusing, idk how it works yet)

With that, we can have 15-17 assignable ranges
11-16
17-22
23-28
29-34 (Maybe problematic for CC 32)
35-40
41-46
47-52
53-58
65-70 (Maybe problematic for CC's 65-70)
71-76
77-82
83-88
89-94
95-100
101-106
107-112
113-118

ChatGPT says that midi CC numbers are uniquely assignable per midi channel. So each controller can start with the first assignable range, and then have multiple scenes that occupy sequential ranges.

I'll need to make sure that I don't try to send 2 controllers to the same channel, whether it's 2 controllers from my own program, or one of mine and my keylab.

Saveable scenes might not be a function of my app, but more a function of the DAW? It would be great to have my program remember which parameters were assigned where and when, but it'll be hard to get that together. It'd need to be a 2-way communication where my application listens to my DAW for ID's/names of parameters being edited, otherwise, there's no scene to save on my application's side. User's will just be assigning controls on the fly and the state of the app is unaffected.

need to handle if loopMidi closes still.

assigning joystick axes is not gonna be intuitive since they almost always send both signals. Learn Midi CC will not be enough to assign them. instead they'll need manually assigned in my GUI.

The Ableton user script will also need installation instructions in order to give someone a useable demo of this product.

### Live Object Model Notes:
[https://docs.cycling74.com/legacy/max8/vignettes/live_object_model](https://docs.cycling74.com/legacy/max8/vignettes/live_object_model)
    (Cursor nudge, looping)
"current_song_time" - property of *live_set*, type float (get, set, observe), the playing position in hte live set in beats
"start_time" - float, the position in the live set where playing will start, in beats.

    (Play/Stop/Record)
"is_playing" - property of *live_set*, type bool (get, set, observe), Get/set if Live's transport is running
"record_mode" - property of *live_set*, type bool (set/get/observe), 1 = the arrangement record button is on.
"session_record", "session_record_status" - ...
--- note function start_playing(), stop_playing(), and trigger_session_record()

    (Looping)
"loop" - property of *live_set*, type bool (get, set, observe), Get/set the enabled state of the Arrangement loop
"loop_length" - property of *live_set*, type float (get/set/observe), Arrangement loop length in beats.
"loop_start" - property of *live_set*, type float (get/set/observe), Arrangement loop start in beats.
--- pseudocode for working with the loop
--- to set loop start, get cursor position with current_song_time and set loop_start to that value.
--- to set loop end, get cursor position and loop start and take the difference. if its negative, no change, if positive, set loop length to difference.
--- note that current_song_time might refer to the position of the playback needle, and not the position of the select cursor. investigate later.
--- note that punch_in and punch_out are properties of live_set as well and can be used for additional functionality.

note that I need to add what MIDI CC number each controller axis is mapped to to my assigns table so that users can manually bind mappings as well as use my "Learn Mode"

